{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 8dfcdd35a404e3870476","webpack:///./es/h.js","webpack:///./es/vnode.js","webpack:///./es/is.js","webpack:///./es/snabbdom.bundle.js","webpack:///./es/snabbdom.js","webpack:///./es/htmldomapi.js","webpack:///./es/thunk.js","webpack:///./es/modules/attributes.js","webpack:///./es/modules/class.js","webpack:///./es/modules/props.js","webpack:///./es/modules/style.js","webpack:///./es/modules/eventlisteners.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,KAAK;QACL;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;QAEA;QACA;;;;;;;;AC7DA;AAAA;AAAA;AAAgC;AACL;;AAE3B;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACO;AACP,iBAAiB;AACjB;AACA;AACA;AACA,YAAY,kDAAQ;AACpB,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,iBAAiB,sDAAY;AAC7B,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAQ;AACpB;AACA;AACA;AACA,iBAAiB,sDAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,qBAAqB;AACxC,gBAAgB,sDAAY;AAC5B,8BAA8B,6DAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6DAAK;AAChB;AACA;AACe,2EAAC,EAAC;;;;;;;;AC9HjB;AAAA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACA;AACO;AACP;AACA;AACA,YAAY;AACZ;AACe,8DAAK,EAAC;;;;;;;;ACjBrB;AAAA;AACO,4BAA4B;AAAA;AAAA;AACnC;AACO;AACP;AACA;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACsB;AACV;AACA;AACA;AACkB;AACxC;AACxB,YAAY,+DAAI;AAChB,IAAI,6EAAgB;AACpB,IAAI,mEAAW;AACf,IAAI,mEAAW;AACf,IAAI,mEAAW;AACf,IAAI,qFAAoB;AACxB;AACA;AACO,wBAAwB,WAAW,6CAAC,GAAG;AAAA;AAAA;AAC/B,6EAAc,EAAC;;;;;;;;AChB9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACD;AACW;AACtC,qBAAqB,wBAAwB;AAC7C,mBAAmB,wBAAwB;AAC3C,kBAAkB,+DAAK,OAAO;AAC9B;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwB;AACQ;;AAEhC;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACO;AACP;AACA,gDAAgD,4DAAU;AAC1D;AACA,eAAe,kBAAkB;AACjC;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAK,4CAA4C;AAChE;;AAEA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA,gBAAgB,kDAAQ;AACxB,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;;;;;;;;ACvfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AAAA;AAAA;AACa,mEAAU,EAAC;;;;;;;;AC9D1B;AAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAC;AACZ;AACA,eAAe,iBAAiB;AAChC;AACA;AACA,KAAK;AACL,EAAE;AAAA;AAAA;AACa,+EAAK,EAAC;;;;;;;;ACpErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,4CAA4C;AAAA;AAAA;AAC9D,0FAAgB,EAAC;;;;;;;;ACjEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,4CAA4C;AAAA;AAAA;AACzD,qFAAW,EAAC;;;;;;;;ACtB3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,4CAA4C;AAAA;AAAA;AACzD,qFAAW,EAAC;;;;;;;;ACtB3B;AACA;AACA,+BAA+B,kBAAkB,SAAS,EAAE,EAAE;AAC9D;AACA;AACA,2BAA2B,iBAAiB,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,EAAE;AAAA;AAAA;AACa,qFAAW,EAAC;;;;;;;;AC5F3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,EAAE;AAAA;AAAA;AACa,8FAAoB,EAAC","file":"snabbdom.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"snabbdom\"] = factory();\n\telse\n\t\troot[\"snabbdom\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8dfcdd35a404e3870476","import { vnode } from './vnode';\nimport * as is from './is';\n\n/**\n *svg使用xml格式定义图图像，所以需要给svg添加namespace，也就是它内部的标签节点需要按照svg标准来渲染\n *\n * @param {*} data svg vnode的data\n * @param {*} children \n * @param {*} sel svg、svg#xxx、svg.xxx\n */\n/*\nconst vnode = h('svg', {\n    attrs: {\n        width: '100%',\n        height: '100%'\n    },\n}, [h('rect', {\n    attrs: {\n        width: 300,\n        height: 100\n    },\n    style: {\n        fill: 'rgb(0, 0, 255)',\n        strokeWidth: 1,\n        stroke: 'rgb(0, 0, 0)'\n    }\n})])\n*/\nfunction addNS(data, children, sel) {\n    data.ns = 'http://www.w3.org/2000/svg';\n    // <foreignObject>元素的作用是可以在其中使用具有其它XML命名空间的XML元素\n    // 就像它内部可以使用xhtml标准解析\n    // <svg xmlns=\"http://www.w3.org/2000/svg\">\n    //     <foreignObject width=\"120\" height=\"50\">\n    //         <body xmlns=\"http://www.w3.org/1999/xhtml\">\n    //             <p>文字。</p>\n    //         </body>\n    //     </foreignObject>\n    // </svg>\n    // 它本身不用添加ns\n    if (sel !== 'foreignObject' && children !== undefined) {\n        for (let i = 0; i < children.length; ++i) {\n            let childData = children[i].data;\n            if (childData !== undefined) {\n                addNS(childData, children[i].children, children[i].sel);\n            }\n        }\n    }\n}\n\n/**\n *就是处理传进来的参数，创建一个Vnode对象，就像Vue里的render函数一样\n *\n * @export\n * @param {*} sel 节点类型\n * @param {*} b \n * @param {*} c\n * @returns\n */\nexport function h(sel, b, c) {\n    var data = {}, children, text, i;\n    if (c !== undefined) {\n        // 若是三参均在，那么b就是data、c就是children\n        data = b;\n        if (is.array(c)) {\n            // 'div', { id: 'container'}, [vnode1, vnode2...]\n            // 若是c是数组，那么就是vnode子元素\n            children = c;\n        }\n        else if (is.primitive(c)) {\n            // 'div', { id: 'container'}, 123\n            // 若c是字符串或者数字，那么该节点就是文本节点\n            text = c;\n        }\n        else if (c && c.sel) {\n            // 'div', { id: 'container'}, vnode1\n            // 若是这种传参，那么转成数组即可\n            children = [c];\n        }\n    }\n    else if (b !== undefined) {\n        if (is.array(b)) {\n            // 'div', [vnode1, vnode2...]\n            children = b;\n        }\n        else if (is.primitive(b)) {\n            // 'div', 123\n            text = b;\n        }\n        else if (b && b.sel) {\n            // 'div', vnode1\n            children = [b];\n        }\n        else {\n            // 'div', {\n            //     style: {\n            //         fontWeight: 'normal',\n            //         fontStyle: 'italic'\n            //     }\n            // }\n            data = b;\n        }\n    }\n    /*\n    h('div', {\n        style: {\n            fontWeight: 'normal',\n            fontStyle: 'italic'\n        }\n    }, [1, 2, 3])*/\n    // 这时候判断下children是否存在，存在的话就判断下每项子元素是否是数字或者字符串，是的话就把它转成vnode对象\n    if (children !== undefined) {\n        for (i = 0; i < children.length; ++i) {\n            if (is.primitive(children[i]))\n                children[i] = vnode(undefined, undefined, undefined, children[i], undefined);\n        }\n    }\n    // sel: svg、svg#xxx、svg.xxx\n    // 也就是这个节点是svg的话那么需要处理下namespace的问题\n    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&\n        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {\n        addNS(data, children, sel);\n    }\n    return vnode(sel, data, children, text, undefined);\n}\n;\nexport default h;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/h.js\n// module id = 0\n// module chunks = 0","/**Vnode对象类型\n *\n *\n * @export\n * @param {*} sel 节点类型，eg：div、span#a.b（<span id=\"a\" class=\"b\">）\n * @param {*} data 节点数据，包括style、attr、event等等\n * @param {*} children 子元素数组\n * @param {*} text 节点的文本内容\n * @param {*} elm 该vnode对应的真实的element\n * @returns\n */\n// 值得注意的是，text按理可以放进children，不过因为有了text，那么肯定就没有children，反之亦然。所以单独放出来，便于处理\nexport function vnode(sel, data, children, text, elm) {\n    // 用于vnode之间的比对\n    let key = data === undefined ? undefined : data.key;\n    return { sel, data, children, text, elm, key };\n}\nexport default vnode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/vnode.js\n// module id = 1\n// module chunks = 0","// Array.isArray引用，若是想换下判断array的方法就很方便了\nexport const array = Array.isArray;\n// 其实就是为了方便传参用的，毕竟比如我生成一个textContent是abc的div，还写一大串，显得有点麻烦\nexport function primitive(s) {\n    return typeof s === 'string' || typeof s === 'number';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/is.js\n// module id = 2\n// module chunks = 0","import { init } from './snabbdom';\nimport { attributesModule } from './modules/attributes'; // for setting attributes on DOM elements\nimport { classModule } from './modules/class'; // makes it easy to toggle classes\nimport { propsModule } from './modules/props'; // for setting properties on DOM elements\nimport { styleModule } from './modules/style'; // handles styling on elements with support for animations\nimport { eventListenersModule } from './modules/eventlisteners'; // attaches event listeners\nimport { h } from './h'; // helper function for creating vnodes\nvar patch = init([\n    attributesModule,\n    classModule,\n    propsModule,\n    styleModule,\n    eventListenersModule\n]);\n// 创建Virtual DOM（h）、比较新旧DOM且更新UI（patch）\nexport const snabbdomBundle = { patch, h: h };\nexport default snabbdomBundle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/snabbdom.bundle.js\n// module id = 3\n// module chunks = 0","import vnode from './vnode';\nimport * as is from './is';\nimport htmlDomApi from './htmldomapi';\nfunction isUndef(s) { return s === undefined; }\nfunction isDef(s) { return s !== undefined; }\nconst emptyNode = vnode('', {}, [], undefined, undefined);\n/**\n *判断俩个node是否一样，也就是是否需要被替换\n *\n * @param {*} vnode1\n * @param {*} vnode2\n * @returns\n */\nfunction sameVnode(vnode1, vnode2) {\n    // key一样，且节点type也得一样\n    // 这俩一样的话其它的修改下属性就好了\n    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\n\nfunction isVnode(vnode) {\n    return vnode.sel !== undefined;\n}\n// 根据子节点返回key-index map，便于根据key寻早节点\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    var _a;\n    const map = {};\n    for (let i = beginIdx; i <= endIdx; ++i) {\n        const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;\n        if (key !== undefined) {\n            map[key] = i;\n        }\n    }\n    return map;\n}\n// 全局钩子只有这六种\n// 节点钩子有8种 init create insert prepatch update postpatch destroy remove \nconst hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];\nexport { h } from './h';\nexport { thunk } from './thunk';\n\n/**\n *根据传入的modules和domApi返回一个path函数\n *方便扩展，而且不同的平台就像Weex的domApi也可以自定义\n * \n * @export\n * @param {*} modules \n * @param {*} domApi\n * @returns\n */\nexport function init(modules, domApi) {\n    let i, j, cbs = {};\n    const api = domApi !== undefined ? domApi : htmlDomApi;\n    // 把传入的modules里提供的方法按照hooks分门别类存入cbs，方便之后调用\n    for (i = 0; i < hooks.length; ++i) {\n        cbs[hooks[i]] = [];\n        for (j = 0; j < modules.length; ++j) {\n            const hook = modules[j][hooks[i]];\n            if (hook !== undefined) {\n                cbs[hooks[i]].push(hook);\n            }\n        }\n    }\n    // 把真实的dom转成vnode\n    function emptyNodeAt(elm) {\n        const id = elm.id ? '#' + elm.id : '';\n        const c = elm.className ? '.' + elm.className.split(' ').join('.') : '';\n        return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n    }\n\n    /**\n     * 创建一个删除的回调，根据传入的remove监听器的数量，每次回调运行都会--，为0的时候真正删除元素\n     *\n     * @param {*} childElm 要删除的子节点\n     * @param {*} listeners 监听器的个数\n     * @returns\n     */\n    function createRmCb(childElm, listeners) {\n        return function rmCb() {\n            if (--listeners === 0) {\n                const parent = api.parentNode(childElm);\n                api.removeChild(parent, childElm);\n            }\n        };\n    }\n    /**\n     *把vnode转成真实dom\n     *\n     * @param {*} vnode\n     * @param {*} insertedVnodeQueue\n     * @returns\n     */\n    function createElm(vnode, insertedVnodeQueue) {\n        var _a, _b, _c;\n        let i, data = vnode.data;\n        if (data !== undefined) {\n            // 就是获取init hook\n            /**\n                h('div', {\n                    hook: {\n                        init(vnode) {\n                            console.log(vnode)\n                        }\n                    }\n                }, [12])\n             */\n            // const init = data.hook?.init;\n            const init = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;\n            if (isDef(init)) {\n                init(vnode);\n                // 因为init hook可能处理了这个vnode导致vnode.data有变化，这里缓存下data下文待用\n                data = vnode.data;\n            }\n        }\n        let children = vnode.children, sel = vnode.sel;\n        // sel为!，代表注释节点\n        if (sel === '!') {\n            // 处理text为undefined情况\n            if (isUndef(vnode.text)) {\n                vnode.text = '';\n            }\n            // 创建注释节点且挂载到elm属性上\n            vnode.elm = api.createComment(vnode.text);\n        }\n        else if (sel !== undefined) {\n            // Parse selector\n            const hashIdx = sel.indexOf('#');\n            const dotIdx = sel.indexOf('.', hashIdx);\n            // 若是id或者class没有的话那么就赋予sel字符长度\n            // 和下文的if (hash < dot)配套\n            const hash = hashIdx > 0 ? hashIdx : sel.length;\n            const dot = dotIdx > 0 ? dotIdx : sel.length;\n            // 解析出tagName\n            const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;\n            \n            // 看情况调用createElementNS、或者createElement\n            const elm = vnode.elm = isDef(data) && isDef(i = data.ns)\n                ? api.createElementNS(i, tag)\n                : api.createElement(tag);\n            // 要是hash小于dot的话，那么肯定有id，因为id只能在前   #a --> a\n            // 没有class的话，dot就是sel长度，也是必然大于大于hash的\n            if (hash < dot)\n                elm.setAttribute('id', sel.slice(hash + 1, dot));\n            // 设置class   .a.b --> a b\n            if (dotIdx > 0)\n                elm.setAttribute('class', sel.slice(dot + 1).replace(/\\./g, ' '));\n            // 调用module create\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            // 若是存在子元素vnode节点，那么递归将子元素插入当前vnode节点中\n            if (is.array(children)) {\n                for (i = 0; i < children.length; ++i) {\n                    const ch = children[i];\n                    if (ch != null) {\n                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));\n                    }\n                }\n            }\n            // 若是存在文本子节点\n            else if (is.primitive(vnode.text)) {\n                api.appendChild(elm, api.createTextNode(vnode.text));\n            }\n            const hook = vnode.data.hook;\n            /*\n            h('rect', {\n                hook: {\n                    insert(vnode) {\n                        console.log(vnode)\n                    }\n                }\n            })\n            */\n            if (isDef(hook)) {\n                // if (hook.create) hook.create(emptyNode, vnode)\n                (_c = (_b = hook).create) === null || _c === void 0 ? void 0 : _c.call(_b, emptyNode, vnode);\n                if (hook.insert) {\n                    // 若是有insert钩子，那么则将其回调push到insertedVnodeQueue，最后在patch批量触发\n                    insertedVnodeQueue.push(vnode);\n                }\n            }\n        }\n        else {\n            // 没有声明sel，那么就是文本节点，这里其实就是h.js ln: 115\n            vnode.elm = api.createTextNode(vnode.text);\n        }\n        // 返回以上创建的elm\n        return vnode.elm;\n    }\n\n    /**\n     * 批量插入节点\n     *\n     * @param {*} parentElm 插入到该节点下\n     * @param {*} before 插入的相对位置，为null的话那么就是插入到结尾\n     * @param {*} vnodes 待插入的nodes数组\n     * @param {*} startIdx 插入的开始索引\n     * @param {*} endIdx 插入的结束索引，也就是vnodes不一定全部插入\n     * @param {*} insertedVnodeQueue\n     */\n    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n            }\n        }\n    }\n\n    /**\n     *手动触发全局以及传入的节点以及其子节点的destory回调\n     *\n     * @param {*} vnode\n     */\n    function invokeDestroyHook(vnode) {\n        var _a, _b, _c, _d;\n        const data = vnode.data;\n        if (data !== undefined) {\n            // data?.hook?.destroy?.(vnode);\n            // 也就是调用该节点的destory回调\n            (_d = (_b = (_a = data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : (_c = _b).destroy) === null || _d === void 0 ? void 0 : _d.call(_c, vnode);\n            // 触发全局destory回调\n            for (let i = 0; i < cbs.destroy.length; ++i)\n                cbs.destroy[i](vnode);\n            // 递归触发子节点回调\n            if (vnode.children !== undefined) {\n                for (let j = 0; j < vnode.children.length; ++j) {\n                    const child = vnode.children[j];\n                    if (child != null && typeof child !== \"string\") {\n                        invokeDestroyHook(child);\n                    }\n                }\n            }\n        }\n    }\n\n    /**批量删除dom节点\n     *就像[vnode1, vnode2]，想删除俩，xxxIdx就得传0, 1\n     *\n     * @param {*} parentElm 待删除元素的父节点\n     * @param {*} vnodes 待删除的节点\n     * @param {*} startIdx 删除的起始坐标\n     * @param {*} endIdx 删除的结束坐标\n     */\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n        var _a, _b, _c;\n        for (; startIdx <= endIdx; ++startIdx) {\n            let listeners, rm, ch = vnodes[startIdx];\n            if (ch != null) {\n                // 非文本节点就得考虑触发destory之类钩子\n                if (isDef(ch.sel)) {\n                    // 手动触发destory钩子回调\n                    invokeDestroyHook(ch);\n                    // 这个+1加的就是因为节点可能有节点remove钩子\n                    listeners = cbs.remove.length + 1;\n                    // 创建删除回调\n                    rm = createRmCb(ch.elm, listeners);\n                    for (let i = 0; i < cbs.remove.length; ++i)\n                        cbs.remove[i](ch, rm);\n                    // const removeHook = ch?.data?.hook?.remove;\n                    // 若是该节点有节点删除钩子，那么调用钩子之后再调删除回调\n                    const removeHook = (_c = (_b = (_a = ch) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.hook) === null || _c === void 0 ? void 0 : _c.remove;\n                    if (isDef(removeHook)) {\n                        removeHook(ch, rm);\n                    }\n                    else {\n                        rm();\n                    }\n                }\n                else { // Text node\n                    // 文本节点直接删除该节点即可\n                    api.removeChild(parentElm, ch.elm);\n                }\n            }\n        }\n    }\n\n    /** \n     * 这里是（核心逻辑），也就是如何比较新旧children且更新到dom树\n     * 这里会的改变真实的节点顺序\n     *\n     * @param {*} parentElm 因为涉及到children的更新，所以需要一个父节点\n     * @param {*} oldCh 父节点下的旧子节点数组\n     * @param {*} newCh 父节点下的新子节点数组\n     * @param {*} insertedVnodeQueue\n     */\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n        // 新旧开始\\结束子节点的索引\\节点\n        // 新旧开始\\结束子节点\n        let oldStartIdx = 0, newStartIdx = 0;\n        let oldEndIdx = oldCh.length - 1;\n        let oldStartVnode = oldCh[0];\n        let oldEndVnode = oldCh[oldEndIdx];\n        let newEndIdx = newCh.length - 1;\n        let newStartVnode = newCh[0];\n        let newEndVnode = newCh[newEndIdx];\n        // 根据（将需要比对的）旧节点children数组转成key-index映射\n        let oldKeyToIdx;\n        let idxInOld;\n        let elmToMove;\n        let before;\n        /** 5个比对规则\n            1. 旧新首首比对，旧新首索引右移\n            2. 旧新尾尾比对，旧新尾索引左移\n            3. 旧新首尾比对，旧首索引右移、新尾索引左移\n            4. 旧新尾首比对，旧尾索引左移、新首索引右移\n            5. 旧新通过key找寻在旧节点组相同的新首节点，新首索引右移（因为新首节点已经比对过了）\n         */\n        // 新旧节点组有一个遍历完毕就退出循环\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n            // 跳过空节点，（规则5的处理）\n            if (oldStartVnode == null) {\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n            }\n            else if (oldEndVnode == null) {\n                oldEndVnode = oldCh[--oldEndIdx];\n            }\n            else if (newStartVnode == null) {\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (newEndVnode == null) {\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\n                // 规则1\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\n                // 规则2\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n                // 规则3\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n                // 插入到旧尾节点之后每一位旧尾结点之后是已经处理过的正确DOM\n                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n                // 规则4\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n                // 因为旧尾节点匹配到了，所以把旧尾结点插入到旧首节点的前面\n                // 因为首节点之前都是已经处理过的正确DOM\n                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                // 创建key-index的map，方便找寻节点\n                if (oldKeyToIdx === undefined) {\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                }\n                // 因为之前四个规则都没通过，所以只能将新节点组的首节点作为处理目标\n                // 首先根据key在旧节点组找到这个处理目标相似的节点索引\n                idxInOld = oldKeyToIdx[newStartVnode.key];\n                if (isUndef(idxInOld)) { // New element\n                    // 没找到，那么该处理目标必然是新节点\n                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    newStartVnode = newCh[++newStartIdx];\n                }\n                else {\n                    // 找到了，那么取到这个需要移动的旧节点\n                    elmToMove = oldCh[idxInOld];\n                    // 因为只是key一样，所以需要判断下sel是否一样\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        // sel不一样，那么就将这个处理目标转成真实DOM，插入\n                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    }\n                    else {\n                        // 一样的话其实就相当于前四个规则的sameVnode\n                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n                        // 然后将旧节点组中对应节点设置为undefined, 代表已经遍历过了，不在遍历\n                        // 否则的话没有置为空，就索引没变，那么必然会又遍历到这个已经处理过的节点，就会引发错误\n                        // 之前四个规则是相对于++\\--索引，这个没办法，因为是无序的\n                        oldCh[idxInOld] = undefined;\n                        // 插入\n                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n                    }\n                    newStartVnode = newCh[++newStartIdx];\n                }\n            }\n        }\n        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n            // 这里因为是就节点组遍历完毕，所以可能新节点组还有新的节点待添加。\n            if (oldStartIdx > oldEndIdx) {\n                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n            }\n            // 反之要是新节点组遍历完，那么可能有旧节点待删除\n            else {\n                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n            }\n        }\n    }\n\n    /**\n     *这里是对node进行真正的patch\n     这里有个前提，也就是若是进入到这个方法，前提就是通过了sameVnode\n        1. 新节点是文本节点，删除旧节点，设置节点文本\n        2. 新节点不是文本节点，那么分一下三种：\n            i. 新旧子节点都在，走updateChildren\n           ii. 新子节点在，旧节点是文本节点。清除旧文本节点，添加新子节点即可\n          iii. 新子节点不在旧子节点在，删除旧子节点即可\n         iiii. 新子节点不在，旧节点是文本节点，清除文本节点\n     * \n     * @param {*} oldVnode\n     * @param {*} vnode\n     * @param {*} insertedVnodeQueue\n     * @returns\n     */\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        /*\n            在patch之前，先调用vnode.data的prepatch钩子\n            const hook = vnode.data?.hook;\n            hook?.prepatch?.(oldVnode, vnode);\n        */\n        const hook = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.hook;\n        (_d = (_b = hook) === null || _b === void 0 ? void 0 : (_c = _b).prepatch) === null || _d === void 0 ? void 0 : _d.call(_c, oldVnode, vnode);\n        \n        const elm = vnode.elm = oldVnode.elm;\n        let oldCh = oldVnode.children;\n        let ch = vnode.children;\n        // 新旧vnode一样的话那么必然没变化，返回即可\n        if (oldVnode === vnode)\n            return;\n        // 若是新vnode有数据，那么调用模块的update回调更新内容，并且调用update hook\n        if (vnode.data !== undefined) {\n            for (let i = 0; i < cbs.update.length; ++i)\n                cbs.update[i](oldVnode, vnode);\n            (_g = (_e = vnode.data.hook) === null || _e === void 0 ? void 0 : (_f = _e).update) === null || _g === void 0 ? void 0 : _g.call(_f, oldVnode, vnode);\n        }\n        // 若不是文本节点\n        if (isUndef(vnode.text)) {\n            if (isDef(oldCh) && isDef(ch)) {\n                // 新旧子节点都在，且不相同，那么更新子节点\n                // 这里是（核心逻辑），也就是如何比较新旧children且更新\n                if (oldCh !== ch)\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n            }\n            else if (isDef(ch)) {\n                // 若是只是新的子节点存在，那么要是旧的是文本子节点那么清除即可\n                if (isDef(oldVnode.text))\n                    api.setTextContent(elm, '');\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            }\n            else if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            else if (isDef(oldVnode.text)) {\n                api.setTextContent(elm, '');\n            }\n        }\n        else if (oldVnode.text !== vnode.text) {\n            if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            api.setTextContent(elm, vnode.text);\n        }\n        //patch完，触发postpatch钩子\n        // hook?.postpatch?.(oldVnode, vnode);\n        (_k = (_h = hook) === null || _h === void 0 ? void 0 : (_j = _h).postpatch) === null || _k === void 0 ? void 0 : _k.call(_j, oldVnode, vnode);\n    }\n    return function patch(oldVnode, vnode) {\n        let i, elm, parent;\n        // 创建插入队列，最终都是传入到createElm方法里push要转成dom的每一个vnode\n        const insertedVnodeQueue = [];\n        // \n        for (i = 0; i < cbs.pre.length; ++i)\n            cbs.pre[i]();\n        if (!isVnode(oldVnode)) {\n            oldVnode = emptyNodeAt(oldVnode);\n        }\n        if (sameVnode(oldVnode, vnode)) {\n            // 若是俩节点相似，那么更新即可\n            patchVnode(oldVnode, vnode, insertedVnodeQueue);\n        }\n        else {\n            // 若是不相似，那么把旧节点整个干掉，替换成新的即可\n            elm = oldVnode.elm;\n            // 获取现有节点的父元素，用于之后插入新元素以及删除旧元素\n            parent = api.parentNode(elm);\n            // 创建新元素dom\n            createElm(vnode, insertedVnodeQueue);\n            if (parent !== null) {\n                // 这时候vnode里以及挂载了新创建的elm，插入到旧元素之后\n                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n                // 真正去删除旧节点\n                removeVnodes(parent, [oldVnode], 0, 0);\n            }\n        }\n        // 循环遍历触发insert钩子，这时候已经插入到DOM树了\n        for (i = 0; i < insertedVnodeQueue.length; ++i) {\n            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n        }\n        // patch完成后触发post回调\n        for (i = 0; i < cbs.post.length; ++i)\n            cbs.post[i]();\n        return vnode;\n    };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/snabbdom.js\n// module id = 4\n// module chunks = 0","function createElement(tagName) {\n    return document.createElement(tagName);\n}\nfunction createElementNS(namespaceURI, qualifiedName) {\n    return document.createElementNS(namespaceURI, qualifiedName);\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    return node.nextSibling;\n}\nfunction tagName(elm) {\n    return elm.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction getTextContent(node) {\n    return node.textContent;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isText(node) {\n    return node.nodeType === 3;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\nexport const htmlDomApi = {\n    createElement,\n    createElementNS,\n    createTextNode,\n    createComment,\n    insertBefore,\n    removeChild,\n    appendChild,\n    parentNode,\n    nextSibling,\n    tagName,\n    setTextContent,\n    getTextContent,\n    isElement,\n    isText,\n    isComment,\n};\nexport default htmlDomApi;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/htmldomapi.js\n// module id = 5\n// module chunks = 0","import { h } from './h';\n\n// 就是把现有的vnode的数据拷贝到空壳vnode，使得它变成一个真的vnode\nfunction copyToThunk(vnode, thunk) {\n    thunk.elm = vnode.elm;\n    // 值得注意的是，把空壳vnode的fn和args这俩个比对参数赋值给旧vnode\n    // 其实感觉没啥用，因为没有影响到现有的对象。毕竟vnode都是新创的，唯一一个不是新创的那也是通过了校验，也就是fn、args一致\n    vnode.data.fn = thunk.data.fn;\n    vnode.data.args = thunk.data.args;\n    thunk.data = vnode.data;\n    thunk.children = vnode.children;\n    thunk.text = vnode.text;\n    thunk.elm = vnode.elm;\n}\n\n// init用于createElement的时候，就没比对。那么需要真正的vnode去创建一个真实的DOM，这个vnode就在init hook里使用fn创建\nfunction init(thunk) {\n    const cur = thunk.data;\n    const vnode = cur.fn.apply(undefined, cur.args);\n    copyToThunk(vnode, thunk);\n}\n/**\n * prepatch\n *\n * @param {*} oldVnode 旧vnode\n * @param {*} thunk 空壳vnode\n * @returns\n */\nfunction prepatch(oldVnode, thunk) {\n    let i, old = oldVnode.data, cur = thunk.data;\n    const oldArgs = old.args, args = cur.args;\n    // 判断下fn是不是一样的，参数是不是一样的\n    if (old.fn !== cur.fn || oldArgs.length !== args.length) {\n        // 不一样的话就使用空壳vnode的fn创建一个vnode作为旧node\n        copyToThunk(cur.fn.apply(undefined, args), thunk);\n        return;\n    }\n    // 比对下每个参数\n    for (i = 0; i < args.length; ++i) {\n        if (oldArgs[i] !== args[i]) {\n            copyToThunk(cur.fn.apply(undefined, args), thunk);\n            return;\n        }\n    }\n    // 若是函数参数一致，那么现有的vnode和要比对的新vnode一样\n    copyToThunk(oldVnode, thunk);\n}\n/**\n * 伪造一个vnode（没有有效的sel、可以有有效的key）\n * sel没什么用，就是用于占位\n * @param {*} sel \n * @param {*} key \n * @param {*} fn 这个就是真正创建vnode的方法，一旦前后比对不一致就用这个方法创建真正的vnode\n * @param {*} args 创建vnode所用的参数\n */\nexport const thunk = function thunk(sel, key, fn, args) {\n    if (args === undefined) {\n        args = fn;\n        fn = key;\n        key = undefined;\n    }\n    return h(sel, {\n        key: key,\n        hook: { init, prepatch }, \n        fn: fn,\n        args: args\n    });\n};\nexport default thunk;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/thunk.js\n// module id = 6\n// module chunks = 0","const xlinkNS = 'http://www.w3.org/1999/xlink';\nconst xmlNS = 'http://www.w3.org/XML/1998/namespace';\nconst colonChar = 58;\nconst xChar = 120;\n/**\n *\n *\n * @param {*} oldVnode 老node\n * @param {*} vnode 新node\n * @returns\n */\nfunction updateAttrs(oldVnode, vnode) {\n    var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs;\n    if (!oldAttrs && !attrs)\n        return;\n    if (oldAttrs === attrs)\n        return;\n    oldAttrs = oldAttrs || {};\n    attrs = attrs || {};\n    // update modified attributes, add new attributes\n    // 遍历新node的attrs，若是和旧的不一样，那么久更新attr\n    for (key in attrs) {\n        const cur = attrs[key];\n        const old = oldAttrs[key];\n        if (old !== cur) {\n            if (cur === true) {\n                // 若新的值是true，那么久设置为空\n                // 其实就是<input autofocus />、<input autofocus=\"true\" />\n                elm.setAttribute(key, \"\");\n            }\n            else if (cur === false) {\n                // 若是false，那么删掉这个属性\n                elm.removeAttribute(key);\n            }\n            else {\n                // 要是属性名是不是x开头，就像width、height\n                if (key.charCodeAt(0) !== xChar) {\n                    elm.setAttribute(key, cur);\n                }\n                // key: xml:lang\n                else if (key.charCodeAt(3) === colonChar) {\n                    // Assume xml namespace\n                    elm.setAttributeNS(xmlNS, key, cur);\n                }\n                // key: xmlns:xlink、xlink:href\n                else if (key.charCodeAt(5) === colonChar) {\n                    // Assume xlink namespace\n                    elm.setAttributeNS(xlinkNS, key, cur);\n                }\n                else {\n                    elm.setAttribute(key, cur);\n                }\n            }\n        }\n    }\n    // remove removed attributes\n    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)\n    // the other option is to remove all attributes with value == undefined\n    for (key in oldAttrs) {\n        if (!(key in attrs)) {\n            elm.removeAttribute(key);\n        }\n    }\n}\nexport const attributesModule = { create: updateAttrs, update: updateAttrs };\nexport default attributesModule;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/modules/attributes.js\n// module id = 7\n// module chunks = 0","function updateClass(oldVnode, vnode) {\n    var cur, name, elm = vnode.elm, oldClass = oldVnode.data.class, klass = vnode.data.class;\n    if (!oldClass && !klass)\n        return;\n    if (oldClass === klass)\n        return;\n    oldClass = oldClass || {};\n    klass = klass || {};\n    for (name in oldClass) {\n        if (!klass[name]) {\n            elm.classList.remove(name);\n        }\n    }\n    for (name in klass) {\n        cur = klass[name];\n        if (cur !== oldClass[name]) {\n            // .classList.add 、 .classList.remove\n            elm.classList[cur ? 'add' : 'remove'](name);\n        }\n    }\n}\nexport const classModule = { create: updateClass, update: updateClass };\nexport default classModule;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/modules/class.js\n// module id = 8\n// module chunks = 0","function updateProps(oldVnode, vnode) {\n    var key, cur, old, elm = vnode.elm, oldProps = oldVnode.data.props, props = vnode.data.props;\n    if (!oldProps && !props)\n        return;\n    if (oldProps === props)\n        return;\n    oldProps = oldProps || {};\n    props = props || {};\n    for (key in oldProps) {\n        if (!props[key]) {\n            delete elm[key];\n        }\n    }\n    for (key in props) {\n        cur = props[key];\n        old = oldProps[key];\n        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {\n            elm[key] = cur;\n        }\n    }\n}\nexport const propsModule = { create: updateProps, update: updateProps };\nexport default propsModule;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/modules/props.js\n// module id = 9\n// module chunks = 0","// Bindig `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.\nvar raf = (typeof window !== 'undefined' && (window.requestAnimationFrame).bind(window)) || setTimeout;\nvar nextFrame = function (fn) { raf(function () { raf(fn); }); };\nvar reflowForced = false;\nfunction setNextFrame(obj, prop, val) {\n    nextFrame(function () { obj[prop] = val; });\n}\nfunction updateStyle(oldVnode, vnode) {\n    var cur, name, elm = vnode.elm, oldStyle = oldVnode.data.style, style = vnode.data.style;\n    if (!oldStyle && !style)\n        return;\n    if (oldStyle === style)\n        return;\n    oldStyle = oldStyle || {};\n    style = style || {};\n    var oldHasDel = 'delayed' in oldStyle;\n    for (name in oldStyle) {\n        if (!style[name]) {\n            if (name[0] === '-' && name[1] === '-') {\n                elm.style.removeProperty(name);\n            }\n            else {\n                elm.style[name] = '';\n            }\n        }\n    }\n    for (name in style) {\n        cur = style[name];\n        if (name === 'delayed' && style.delayed) {\n            for (let name2 in style.delayed) {\n                cur = style.delayed[name2];\n                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {\n                    setNextFrame(elm.style, name2, cur);\n                }\n            }\n        }\n        else if (name !== 'remove' && cur !== oldStyle[name]) {\n            if (name[0] === '-' && name[1] === '-') {\n                elm.style.setProperty(name, cur);\n            }\n            else {\n                elm.style[name] = cur;\n            }\n        }\n    }\n}\nfunction applyDestroyStyle(vnode) {\n    var style, name, elm = vnode.elm, s = vnode.data.style;\n    if (!s || !(style = s.destroy))\n        return;\n    for (name in style) {\n        elm.style[name] = style[name];\n    }\n}\nfunction applyRemoveStyle(vnode, rm) {\n    var s = vnode.data.style;\n    if (!s || !s.remove) {\n        rm();\n        return;\n    }\n    if (!reflowForced) {\n        vnode.elm.offsetLeft;\n        reflowForced = true;\n    }\n    var name, elm = vnode.elm, i = 0, compStyle, style = s.remove, amount = 0, applied = [];\n    for (name in style) {\n        applied.push(name);\n        elm.style[name] = style[name];\n    }\n    compStyle = getComputedStyle(elm);\n    var props = compStyle['transition-property'].split(', ');\n    for (; i < props.length; ++i) {\n        if (applied.indexOf(props[i]) !== -1)\n            amount++;\n    }\n    elm.addEventListener('transitionend', function (ev) {\n        if (ev.target === elm)\n            --amount;\n        if (amount === 0)\n            rm();\n    });\n}\nfunction forceReflow() {\n    reflowForced = false;\n}\nexport const styleModule = {\n    pre: forceReflow,\n    create: updateStyle,\n    update: updateStyle,\n    destroy: applyDestroyStyle,\n    remove: applyRemoveStyle\n};\nexport default styleModule;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/modules/style.js\n// module id = 10\n// module chunks = 0","function invokeHandler(handler, vnode, event) {\n    if (typeof handler === \"function\") {\n        // call function handler\n        handler.call(vnode, event, vnode);\n    }\n    else if (typeof handler === \"object\") {\n        // call handler with arguments\n        if (typeof handler[0] === \"function\") {\n            // special case for single argument for performance\n            if (handler.length === 2) {\n                handler[0].call(vnode, handler[1], event, vnode);\n            }\n            else {\n                var args = handler.slice(1);\n                args.push(event);\n                args.push(vnode);\n                handler[0].apply(vnode, args);\n            }\n        }\n        else {\n            // call multiple handlers\n            for (var i = 0; i < handler.length; i++) {\n                invokeHandler(handler[i], vnode, event);\n            }\n        }\n    }\n}\nfunction handleEvent(event, vnode) {\n    var name = event.type, on = vnode.data.on;\n    // call event handler(s) if exists\n    if (on && on[name]) {\n        invokeHandler(on[name], vnode, event);\n    }\n}\nfunction createListener() {\n    return function handler(event) {\n        handleEvent(event, handler.vnode);\n    };\n}\nfunction updateEventListeners(oldVnode, vnode) {\n    var oldOn = oldVnode.data.on, oldListener = oldVnode.listener, oldElm = oldVnode.elm, on = vnode && vnode.data.on, elm = (vnode && vnode.elm), name;\n    // optimization for reused immutable handlers\n    if (oldOn === on) {\n        return;\n    }\n    // remove existing listeners which no longer used\n    if (oldOn && oldListener) {\n        // if element changed or deleted we remove all existing listeners unconditionally\n        if (!on) {\n            for (name in oldOn) {\n                // remove listener if element was changed or existing listeners removed\n                oldElm.removeEventListener(name, oldListener, false);\n            }\n        }\n        else {\n            for (name in oldOn) {\n                // remove listener if existing listener removed\n                if (!on[name]) {\n                    oldElm.removeEventListener(name, oldListener, false);\n                }\n            }\n        }\n    }\n    // add new listeners which has not already attached\n    if (on) {\n        // reuse existing listener or create new\n        var listener = vnode.listener = oldVnode.listener || createListener();\n        // update vnode for listener\n        listener.vnode = vnode;\n        // if element changed or added we add all needed listeners unconditionally\n        if (!oldOn) {\n            for (name in on) {\n                // add listener if element was changed or new listeners added\n                elm.addEventListener(name, listener, false);\n            }\n        }\n        else {\n            for (name in on) {\n                // add listener if new listener added\n                if (!oldOn[name]) {\n                    elm.addEventListener(name, listener, false);\n                }\n            }\n        }\n    }\n}\nexport const eventListenersModule = {\n    create: updateEventListeners,\n    update: updateEventListeners,\n    destroy: updateEventListeners\n};\nexport default eventListenersModule;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./es/modules/eventlisteners.js\n// module id = 11\n// module chunks = 0"],"sourceRoot":""}